#ifndef STACK_N_HXX
#define STACK_N_HXX

#include <algorithm>
#include <cassert>
#include <exception>
#include <functional>
#include <iostream>
#include <optional>
#include <string>
#include <ranges>



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    template <typename _Ty>
    concept is_class = std::is_class<typename std::decay<_Ty>::type>::value;
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------

//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    template <typename> class stack;
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



// START NODE
//
template <typename _Ty>
    class node final
{

public:
    friend class stack<_Ty>;


public:
    using value_type      = _Ty;
    using reference       = std::add_lvalue_reference_t<_Ty>;
    using const_reference = std::add_lvalue_reference_t<std::add_const_t<_Ty>>;
    using pointer         = std::add_pointer_t<_Ty>;
    using const_pointer   = std::add_pointer_t<std::add_const_t<_Ty>>;


public:
    using node_ptr_t = std::pointer_traits<_Ty*>::template rebind<node>;

public:
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    node() noexcept requires( std::default_initializable<_Ty> )
        : m_data{ _Ty{} }
        , m_next{ nullptr }
    {}
//  -------------------------------------------------------------------------
    node( _Ty const &p_value, node_ptr_t p_next ) noexcept requires( std::copy_constructible<_Ty> )
        : m_data{ p_value }
        , m_next{ p_next }
    {}
//  -------------------------------------------------------------------------
    node( _Ty &&p_value, node_ptr_t p_next ) noexcept requires( std::move_constructible<_Ty> )
        : m_data{ std::move(p_value) }
        , m_next{ p_next }
    {}
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------


public:
//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------
    auto data()       noexcept -> decltype(auto) { return m_data; }
//  --------------------------------------------------------------------------
    auto data() const noexcept -> decltype(auto) { return m_data; }
//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------


//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------
    auto next()       noexcept -> decltype(auto) { return m_next; }
//  --------------------------------------------------------------------------
    auto next() const noexcept -> decltype(auto) { return m_next; }
//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------


private:
    value_type m_data;
    node_ptr_t m_next;
};

//  //

//* END NODE *//




template <typename _Ty>
    class stack final
{

public:
    using node_type = node<_Ty>;
    using node_t    = typename node_type::node_ptr_t;

//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------
public:
    using value_type      = _Ty;
    using reference       = std::add_lvalue_reference_t<_Ty>;
    using const_reference = std::add_lvalue_reference_t<std::add_const_t<_Ty>>;
    using pointer         = std::add_pointer_t<_Ty>;
    using const_pointer   = std::add_pointer_t<std::add_const_t<_Ty>>;
    using size_type       = std::size_t;
//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------

public:
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    stack() noexcept;
//  -------------------------------------------------------------------------
    template <std::input_iterator I, std::sentinel_for<I> S>
    stack( I, S ) noexcept requires( std::convertible_to<std::iter_value_t<I>, _Ty> );
//  -------------------------------------------------------------------------
    template <std::ranges::input_range R>
    stack( R && ) noexcept requires( std::convertible_to<std::ranges::range_value_t<R>, _Ty> );
//  -------------------------------------------------------------------------
    stack( stack const & ) noexcept ;
//  -------------------------------------------------------------------------
    stack( stack && ) noexcept;
//  -------------------------------------------------------------------------
    auto operator=( stack ) noexcept -> decltype(auto);
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    void push_front( _Ty const& ) noexcept;
//  -------------------------------------------------------------------------
    void push( _Ty const& )       noexcept;
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------


//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    template <typename ...ARGS>
    void emplace_front( ARGS && ... ) noexcept requires( is_class<_Ty> && std::constructible_from<_Ty, ARGS...> );
//  -------------------------------------------------------------------------
    template <typename ...ARGS>
    void emplace( ARGS && ... ) noexcept requires( is_class<_Ty> && std::constructible_from<_Ty, ARGS...> );
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    void pop_front();
//  -------------------------------------------------------------------------
    void pop();
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    [[nodiscard]] auto peep() const noexcept -> std::optional<node_type>;
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    [[nodiscard]] auto empty() const noexcept -> bool;
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    [[nodiscard]] auto size() const noexcept -> size_type;
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    ~stack();
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    friend void swap( stack & p_lhs, stack & p_rhs )
    {
        using std::swap;

        swap( p_lhs.m_head, p_rhs.m_head );
        swap( p_lhs.m_size, p_rhs.m_size );
    }
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    void debug() const noexcept
    {
        node_t v_node = m_head;

        while ( v_node )
        {
            std::cout << v_node->data() << ' ';
            v_node = v_node->next();
        }

        std::cout << std::endl;

    }
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
private:
    node_t    m_head;
    size_type m_size;
};




//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    template <typename _Ty>
    template <std::input_iterator I, std::sentinel_for<I> S>
    stack<_Ty>::stack( I p_begin, S p_end ) noexcept requires( std::convertible_to<std::iter_value_t<I>, _Ty> )
        : stack()
    {
        using std::placeholders::_1;

        std::ranges::for_each( p_begin, p_end, std::bind(&stack::push_front, this, _1) );
    }
//  -------------------------------------------------------------------------
    template <typename _Ty>
    template <std::ranges::input_range R>
    stack<_Ty>::stack( R && p_container ) noexcept requires( std::convertible_to<std::ranges::range_value_t<R>, _Ty> )
        : stack( std::ranges::begin(p_container), std::ranges::end(p_container) )
    {
    }
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------




//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    template <typename _Ty>
    template <typename ...ARGS>
    void stack<_Ty>::emplace_front( ARGS && ...p_args ) noexcept requires( is_class<_Ty> && std::constructible_from<_Ty, ARGS...> )
    {
        if ( ( m_head = new (std::nothrow) node_type{ _Ty{ std::forward<ARGS>(p_args)...}, m_head } ) )
        {
            m_size = -(~m_size);
        }
    }
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------
    template <typename _Ty>
    template <typename ...ARGS>
    void stack<_Ty>::emplace( ARGS && ...p_args ) noexcept requires( is_class<_Ty> && std::constructible_from<_Ty, ARGS...> )
    {
        emplace_front( std::forward<ARGS>(p_args)...);
    }
//  -------------------------------------------------------------------------
//  -------------------------------------------------------------------------



//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------
    extern template class stack<int>;
    extern template class stack<char>;
    extern template class stack<long>;
    extern template class stack<short>;
    extern template class stack<unsigned int>;
    extern template class stack<unsigned char>;
    extern template class stack<unsigned long>;
    extern template class stack<unsigned short>;
    extern template class stack<float>;
    extern template class stack<double>;
    extern template class stack<std::string>;
//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------
#endif
