//  --------------------------------------------------------------------------
//  -----------------------------------------size_---------------------------------
    #include <ds/queue.hxx>
//  --------------------------------------------------------------------------
//  --------------------------------------------------------------------------




// start queue
// start queue
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    queue<T>::queue() requires( std::default_initializable<T> )
    {
        try
        {
            m_head = new node_type{};
            m_size = 0ul;
        }
        catch(...)
        {
            m_head = ( delete m_head, nullptr );

            throw;
        }
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------




//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    queue<T>::queue( queue const & p_outer )
        : queue()
    {

        node_t v_curr = p_outer.m_head->m_next;
        node_t v_node    = nullptr;


        while ( v_curr != p_outer.m_head )
        {

            try
            {
                v_node = new node_type( v_curr->m_data );
            }
            catch(...)
            {
                v_node = ( delete v_node, nullptr );

                throw;
            }

            m_head->push_back(v_node);
            
            v_curr = v_curr->m_next;
        }

        m_size = p_outer.m_size;
    } 
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------




//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    queue<T>::queue( queue && p_outer ) noexcept
        : queue()
    {
        swap( *this, p_outer );
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------




//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    auto queue<T>::operator=( queue p_rhs ) -> decltype(auto)
    {
        swap( *this, p_rhs );

        return *this;
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------




//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    void queue<T>::pop_front()
    {
        assert( not empty() );

        node_t v_curr = m_head->m_next;
        
        m_head->m_next          = v_curr->m_next;
        v_curr->m_next->m_prev  = m_head;
        v_curr                  = ( delete v_curr, nullptr );

        m_size = ~(-m_size);
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------



//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    void queue<T>::pop()
    {
        pop_front();
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------



//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    [[nodiscard]] auto queue<T>::empty() const noexcept -> bool 
    {
        return ( ( m_head == m_head->m_prev ) && ( m_head == m_head->m_next ) );
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------



//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    [[nodiscard]] auto queue<T>::size() const noexcept -> queue::size_type
    {
        return m_size;
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------





//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    [[nodiscard]] auto queue<T>::peek() const noexcept -> std::optional<node_type>
    {
        return not empty()  ? std::optional{ *m_head->m_next }
                            : std::nullopt;
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------





//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    [[nodiscard]] auto queue<T>::front() noexcept -> std::optional<node_type>
    {
        return peek();
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------





//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    [[nodiscard]] auto queue<T>::front() const noexcept -> std::optional<node_type>
    {
        return peek();
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------





//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    [[nodiscard]] auto queue<T>::back() noexcept -> std::optional<node_type>
    {
        return not empty()  ? std::optional{ *m_head->m_prev }
                            : std::nullopt;
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------





//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    [[nodiscard]] auto queue<T>::back() const noexcept -> std::optional<node_type>
    {
        return not empty()  ? std::optional{ *m_head->m_prev }
                            : std::nullopt;
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------





//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template <class T>
    queue<T>::~queue()
    {
       while ( not empty() )
       {
            pop_front();
       }

       m_head = ( delete m_head, nullptr );
    }
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------




//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------
    template class queue<int>;
    template class queue<char>;
    template class queue<long>;
    template class queue<short>;
    template class queue<unsigned int>;
    template class queue<unsigned char>;
    template class queue<unsigned long>;
    template class queue<unsigned short>;
    template class queue<float>;
    template class queue<double>;
//  -----------------------------------------------------------------------
//  -----------------------------------------------------------------------